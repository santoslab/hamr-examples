package tc.TempControlSoftwareSystem

import org.sireum._
import tc.TempControlSoftwareSystem._
import tc.GumboXUtil
import tc.GumboXUtil.GumboXResult
import tc.RandomLib
import org.sireum.Random.Gen64
import org.sireum.Random.Impl.Xoshiro256

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

trait TempControlPeriodic_p_tcproc_tempControl_GumboX_TestHarness_ScalaTest_Generator extends TempControlPeriodic_p_tcproc_tempControl_GumboX_TestHarness_ScalaTest {

  def failOnUnsatPreconditions: B = F

  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)

  def getProfiles_P: ISZ[TempControlPeriodic_p_tcproc_tempControl_Profile_P]

  def getDefaultProfile_P: TempControlPeriodic_p_tcproc_tempControl_Profile_P = {
    return TempControlPeriodic_p_tcproc_tempControl_Profile_P (
      name = "Default Port Profile", 
      numTests = 100, 
      api_currentTemp = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), 
      api_fanAck = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), 
      api_setPoint = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))
  }

  def getProfiles_PS: ISZ[TempControlPeriodic_p_tcproc_tempControl_Profile_PS]

  def getDefaultProfile_PS: TempControlPeriodic_p_tcproc_tempControl_Profile_PS = {
    return TempControlPeriodic_p_tcproc_tempControl_Profile_PS (
      name = "Default Port and State Variable Profile", 
      numTests = 100, 
      In_latestFanCmd = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), 
      api_currentTemp = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), 
      api_fanAck = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), 
      api_setPoint = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))
  }

  def next(profile: TempControlPeriodic_p_tcproc_tempControl_Profile_P): Option[TempControlPeriodic_p_tcproc_tempControl_PreState_Container_P] = {
    try {
      val api_currentTemp = profile.api_currentTemp.nextTempSensorTemperature_i()
      val api_fanAck = profile.api_fanAck.nextCoolingFanFanAckType()
      val api_setPoint = profile.api_setPoint.nextTempControlSoftwareSystemSetPoint_i()

      return Some(TempControlPeriodic_p_tcproc_tempControl_PreState_Container_P(api_currentTemp,api_fanAck,api_setPoint))
    } catch {
      case e: AssertionError =>
       // SlangCheck was unable to satisfy a datatype's filter
       return None()
    }
  }

  def nextwL(profile: TempControlPeriodic_p_tcproc_tempControl_Profile_PS): Option[TempControlPeriodic_p_tcproc_tempControl_PreState_Container_PS] = {
    try {
      val In_latestFanCmd = profile.In_latestFanCmd.nextCoolingFanFanCmdType()
      val api_currentTemp = profile.api_currentTemp.nextTempSensorTemperature_i()
      val api_fanAck = profile.api_fanAck.nextCoolingFanFanAckType()
      val api_setPoint = profile.api_setPoint.nextTempControlSoftwareSystemSetPoint_i()

      return Some(TempControlPeriodic_p_tcproc_tempControl_PreState_Container_PS(In_latestFanCmd,api_currentTemp,api_fanAck,api_setPoint))
    } catch {
      case e: AssertionError =>
       // SlangCheck was unable to satisfy a datatype's filter
       return None()
    }
  }

  def numInitialiseTests: Z = 100

  {
    for (i <- 0 to numInitialiseTests) {
      this.registerTest(s"testInitialiseCB_$i") {
        testInitialiseCB() match {
          case GumboXResult.Pre_Condition_Unsat =>
            halt("Infeasible as initialize entry points cannot contain assume clauses and cannot access incoming ports or state variables")
          case GumboXResult.Post_Condition_Fail =>
            fail ("Post condition did not hold")
          case GumboXResult.Post_Condition_Pass =>
            if (verbose) {
              println ("Success!")
            }
        }
      }
    }
  }

  for (profile <- getProfiles_P) {
    testComputeCB_Profile_P(profile)
  }

  def testComputeCB_Profile_P(profile: TempControlPeriodic_p_tcproc_tempControl_Profile_P): Unit = {
    for (i <- 0 to profile.numTests) {
      this.registerTest(s"Profile \"${profile.name}\": testComputeCB_$i") {
        var retry: B = T

        var j: Z = 0
        while (j < GumboXUtil.numTestVectorGenRetries && retry) {
          next(profile) match {
            case Some(o) =>

              if (verbose && j > 0) {
                println(s"Retry $j:")
              }

              val results = testComputeCBV(o)

              if (verbose) {
                val tq = "\"\"\""
                println(st"""Replay Unit Test:
                            |  test("Profile \"${profile.name}\": testComputeCB_$i") {
                            |    val json = st${tq}${tc.JSON.fromTempControlSoftwareSystemTempControlPeriodic_p_tcproc_tempControl_PreState_Container_P(o, T)}${tq}.render
                            |    val testVector = tc.JSON.toTempControlSoftwareSystemTempControlPeriodic_p_tcproc_tempControl_PreState_Container_P(json).left
                            |    assert (testComputeCBV(testVector) == tc.GumboXUtil.GumboXResult.$results)
                            |  }""".render)
              }

              results match {
                case GumboXResult.Pre_Condition_Unsat =>
                case GumboXResult.Post_Condition_Fail =>
                  fail ("Post condition did not hold")
                  retry = F
                case GumboXResult.Post_Condition_Pass =>
                  if (verbose) {
                    println ("Success!")
                  }
                  retry = F
              }
            case _ =>
          }
          j = j + 1
        }

        if (retry) {
          if (failOnUnsatPreconditions) {
            fail ("Unable to satisfy precondition")
          } else if (verbose) {
            cprintln(T, "Unable to satisfy precondition")
          }
        }
      }
    }
  }

  for (profile <- getProfiles_PS) {
    testComputeCBwL_Profile_PS(profile)
  }

  def testComputeCBwL_Profile_PS(profile: TempControlPeriodic_p_tcproc_tempControl_Profile_PS): Unit = {
    for (i <- 0 to profile.numTests) {
      this.registerTest(s"Profile \"${profile.name}\": testComputeCBwL_$i") {
        var retry: B = T

        var j: Z = 0
        while (j < GumboXUtil.numTestVectorGenRetries && retry) {
          nextwL(profile) match {
            case Some(o) =>

              if (verbose && j > 0) {
                println(s"Retry $j:")
              }

              val results = testComputeCBwLV(o)

              if (verbose) {
                val tq = "\"\"\""
                println(st"""Replay Unit Test:
                            |  test("Profile \"${profile.name}\": testComputeCBwL_$i") {
                            |    val json = st${tq}${tc.JSON.fromTempControlSoftwareSystemTempControlPeriodic_p_tcproc_tempControl_PreState_Container_PS(o, T)}${tq}.render
                            |    val testVector = tc.JSON.toTempControlSoftwareSystemTempControlPeriodic_p_tcproc_tempControl_PreState_Container_PS(json).left
                            |    assert (testComputeCBwLV(testVector) == tc.GumboXUtil.GumboXResult.$results)
                            |  }""".render)
              }

              results match {
                case GumboXResult.Pre_Condition_Unsat =>
                case GumboXResult.Post_Condition_Fail =>
                  fail ("Post condition did not hold")
                  retry = F
                case GumboXResult.Post_Condition_Pass =>
                  if (verbose) {
                    println ("Success!")
                  }
                  retry = F
              }
            case _ =>
          }
          j = j + 1
        }

        if (retry) {
          if (failOnUnsatPreconditions) {
            fail ("Unable to satisfy precondition")
          } else if (verbose) {
            cprintln(T, "Unable to satisfy precondition")
          }
        }
      }
    }
  }
}