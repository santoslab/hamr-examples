// #Sireum

package tc.TempControlSoftwareSystem

import org.sireum._
import art._
import tc.SystemTestSuiteSlang.runtimeMonitorStream
import tc._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object TempControlPeriodic_p_tcproc_tempControl_SystemTestAPI {
  /** helper method to set the values of all incoming ports and state variables
    * @param In_latestFanCmd pre-state state variable
    * @param api_currentTemp incoming data port
    * @param api_fanAck incoming data port
    * @param api_setPoint incoming data port
    */
  def put_concrete_inputs(In_latestFanCmd: CoolingFan.FanCmd.Type,
                          api_currentTemp: TempSensor.Temperature_i,
                          api_fanAck: CoolingFan.FanAck.Type,
                          api_setPoint: TempControlSoftwareSystem.SetPoint_i): Unit = {
    put_In_latestFanCmd(In_latestFanCmd)
    put_currentTemp(api_currentTemp)
    put_fanAck(api_fanAck)
    put_setPoint(api_setPoint)
  }

  // setter for state variable
  def put_In_latestFanCmd(value: CoolingFan.FanCmd.Type): Unit = {
    TempControlPeriodic_p_tcproc_tempControl.latestFanCmd = value
  }

  // setter for incoming data port
  def put_currentTemp(value: TempSensor.Temperature_i): Unit = {
    Art.insertInInfrastructurePort(Arch.TempControlSoftwareSystem_p_Instance_tcproc_tempControl.operational_api.currentTemp_Id, TempSensor.Temperature_i_Payload(value))
  }

  // setter for incoming data port
  def put_fanAck(value: CoolingFan.FanAck.Type): Unit = {
    Art.insertInInfrastructurePort(Arch.TempControlSoftwareSystem_p_Instance_tcproc_tempControl.operational_api.fanAck_Id, CoolingFan.FanAck_Payload(value))
  }

  // setter for incoming data port
  def put_setPoint(value: TempControlSoftwareSystem.SetPoint_i): Unit = {
    Art.insertInInfrastructurePort(Arch.TempControlSoftwareSystem_p_Instance_tcproc_tempControl.operational_api.setPoint_Id, TempControlSoftwareSystem.SetPoint_i_Payload(value))
  }

  def fetchContainer(): tc.TempControlSoftwareSystem.TempControlPeriodic_p_tcproc_tempControl_PostState_Container_PS = {
    if (runtimeMonitorStream.contains(Arch.TempControlSoftwareSystem_p_Instance_tcproc_tempControl.id)) {
      val (_, postContainer_) = runtimeMonitorStream.get(Arch.TempControlSoftwareSystem_p_Instance_tcproc_tempControl.id).get
      return postContainer_.asInstanceOf[tc.TempControlSoftwareSystem.TempControlPeriodic_p_tcproc_tempControl_PostState_Container_PS]
    }
    else {
      assert(F, s"No post state recorded for ${Arch.TempControlSoftwareSystem_p_Instance_tcproc_tempControl.name}")
      halt(s"No post state recorded for ${Arch.TempControlSoftwareSystem_p_Instance_tcproc_tempControl.name}")
    }
  }

  def check_concrete_outputs(latestFanCmd: CoolingFan.FanCmd.Type,
                             api_fanCmd: CoolingFan.FanCmd.Type): Unit = {
    var failureReasons: ISZ[ST] = ISZ()

    val actual_latestFanCmd = get_latestFanCmd()
    if (latestFanCmd != actual_latestFanCmd) {
      failureReasons = failureReasons :+ st"'latestFanCmd' did not match expected.  Expected: $latestFanCmd, Actual: $actual_latestFanCmd"
    }
    val actual_fanCmd = get_api_fanCmd()
    if (api_fanCmd != actual_fanCmd) {
      failureReasons = failureReasons :+ st"'fanCmd' did not match expected.  Expected: $api_fanCmd, Actual: $actual_fanCmd"
    }

    assert(failureReasons.isEmpty, st"${(failureReasons, "\n")}".render)
  }

  // getter for state variable
  def get_latestFanCmd(): CoolingFan.FanCmd.Type = {
    return TempControlPeriodic_p_tcproc_tempControl.latestFanCmd
  }

  def get_api_fanCmd(): CoolingFan.FanCmd.Type = {
    return fetchContainer().api_fanCmd
  }
}